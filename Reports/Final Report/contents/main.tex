\section{Main Result}
This chapter provides a detailed description of the process through which the proposed system has been generated. Starting from the requirements elicitation process until the implementation and testing phases, the step by step workflow of the project is reported in the following sections.

\subsection{System Analysis and Planning}
The scope of this project is to develop a platform that provides customisable software products tailored for correlating vendors and customers in the form of both a web platform and a mobile application. To ensure that both the designing and the implementation phases converge to the successful attainment of the project's goals, project management techniques have been applied. As a result, a number of deliverables have been created in order to help identify the specific requirements of both the main and generated systems, as well as to plan and organise the development phase. These deliverables consist of the Conditions of Satisfaction, the Project Overview Statement, the Requirements Breakdown Structure, the Work Package Breakdown and the project's development schedule. 

\subsubsection{The Scoping Process}
The analysis of the project's scope lead to the identification of the Conditions of Satisfaction, which provide the means of establishing when the project has reached the end stage. The COS outlined for this project are:\\\\
1. A fully-functional solution is generated in less than 10 minutes.\\
2. The customers are provided with two different means of using the system.\\
3. The system customisation options cover most types of vendors.\\\\

Having determined the success criteria of the project, the properties of the end system could be established. Derived from the scope of the project, the core functionalities of the system comprise the high-level requirements, which form a necessary and sufficient set for the attainment of the goal \cite{holyer_2016}.\\\\
1. A complete system is delivered based upon specific requirements and features.\\
2. The solution presents a list of offers for the chosen product or service categories based upon distance, rating score or offer value.\\
3. The chosen offer can be purchased and redeemed at the location.\\

This provided a sufficient base for generating an initial Requirements Breakdown Structure. The initial step for identifying the basic features of the system was decomposing the high-level requirements into necessary functions and sub-functions. However, due to the complexity and dynamic nature of the end-solution, the set of system requirements has been constantly adapted throughout the development process. The final form of the Requirements Breakdown Structure is:\\\\
1. A complete system is delivered based upon specific requirements and features.\\
\indent	1.1. A customisation platform is provided to the client.\\
\indent\indent		1.1.1. The client can choose a system based upon location, product or service.\\
\indent\indent		1.1.2. The system must be suitable for offers of different categories.\\
\indent\indent		1.1.2. The client can customise the appearance of the end-system.\\
\indent	1.2. iOS and Web applications, server and database templates are created.\\
\indent\indent		1.2.1. Database templates matching any combination of customisation criteria are designed.\\
\indent\indent		1.2.2. A server component template is created.\\
\indent\indent		1.2.3. An iOS application template is created.\\
\indent\indent		1.2.4. A Web application template is created.\\
\indent	1.3. The necessary and sufficient set of features and functionalities for the generated system are identified.\\
\indent\indent		1.3.1. Any type of solution provides rating, directions and offer description functionalities.\\
\indent\indent		1.3.2. Product or service based solutions offer the possibility of offer purchasing.\\
\indent\indent		1.3.3. Service based solutions provide an appointment management system.\\
2. The solution presents a list of offers for the chosen product or service categories based upon distance, rating score or offer value.\\
\indent	2.1. An updated list of offers is presented, specifying the distance from the customer's current position.\\
\indent\indent		2.1.1. The system can locate the customer's current position.\\
\indent\indent		2.1.2. Customers can view all the offers within a 50 kilometre radius.\\
\indent	2.2. The customer can filter the list of offers.\\
\indent\indent		2.2.1. The list can be sorted by proximity, rating score or offer value.\\
\indent\indent		2.2.2. Customers can manage their favourite locations list.\\
3. The chosen offer can be viewed, purchased and redeemed at the location.\\
\indent	3.1. The solution provides details about the vendor and the location.\\
\indent\indent		3.1.1. The customers can view the description, rating mark and available offers for any location.\\
\indent\indent		3.1.2. The system provides directions to the location via GPS or through Augmented Reality.\\
\indent\indent		3.1.3. Customers can provide a rating mark after purchasing an offer.\\
\indent	3.2. Customers can purchase offers with credit and debit cards.\\
\indent\indent		3.2.1. Customers can add credit to their accounts.\\
\indent\indent		3.2.2. The vendors are transferred the value of an offer when purchased.\\
\indent\indent		3.2.3. The customers receive receipts for their purchases.\\

Following this set of requirements ensured the generation of autonomous systems suitable for any type of product or service. The presentation components provide all the important functionalities needed in customers' search for the best suited offer, as well as a platform for loyalisation by enabling them to select their favourite vendor locations. In addition, this Requirements Breakdown Structure helped in identifying the customisation criteria necessary for covering most of a potential client's requests. As a result, a Project Overview Statement was written in order to record and maintain a reference to the initial decisions for the project.\\

The next step towards identifying the best suited approach to developing the system was prioritising the Scope Triangle. The scope of the project is the most critical aspect, as it must target the needs of a large number of both customers and vendors, thus making it prone to revisions. The system's quality is of close importance, as it is essential to acquiring and maintaining a good customer base. Having less than three months for all of the phases of development, the time for creating such an extensive project is short, proving to be the third most critical aspect. Despite that, the priority is developing an extensive and reliable system. The resource availability and the cost could prove to be an issue in the development of a complete solution. However, these aspects are least likely to change as they are clearly outlined from the beginning.\\

\begin{table}[t]
\centering
    \begin{tabular}{ | l | p{1.2cm} | p{1.2cm} | p{1.2cm} | p{1.2cm} | p{1.2cm} |}
    \hline
    Variable / Priority & Critical (1) & (2) & (3) & (4) & Flexible (5) \\ \hline
    Scope & x &  &  &  &  \\ \hline
    Quality &  & x &  &  &  \\ \hline
    Time &  &  & x &  &  \\ \hline
    Cost &  &  &  & x &  \\ \hline
    Resource availability &  &  &  &  & x \\
    \hline
    \end{tabular}
 \caption{Prioritising the Scope Triangle}
\label{tab:scope_triangle}
\end{table}

While the project started with a clear goal, the solution was not yet fully identified at the time. Even though a minimum set of requirements was identified, both the main and the generated systems were not clearly outlined. In addition, further functionalities for such a retail system could and have been identified further on. Based upon these factors, the analysis conducted previously, as well as on the importance of the project and the amount of time available, the chosen approach towards developing the systems was the Agile Project Management. Thus, the Adaptive Project Management Life Cycle was adopted, outlining the conclusion of the project's scoping phase. 

\subsubsection{The Planning Process}
Having identified the initial requirements for the system, a project plan was outlined in order to organise the following stages of the development process. This provided a clear roadmap for the sequence of steps that needed to be followed as to minimise uncertainty and increase efficiency. However, as the Adaptive lifecycle was chosen as the PMLC, identifying clear tasks and creating an overall schedule was hindered by the large complexity. The approach of solving this issue and maintaining awareness of the progress and results is described in this section.\\

As the depth of the Requirements Breakdown Structure was not known after the features level, the solution could not be clearly defined yet. Thus, the planning process started with documenting and creating an initial plan using a board and sticky notes. This task provided a good initial approach, as it helped in transforming the features of the RBS into work packages and to estimate the duration and complexity of each and every one of them as can be seen in Figure~\ref{fig:wbs} in the Appendix. This was followed by organising the identified work packages using a software tool in order to maintain persistency and to enhance the visual aspect of the schedule.\\

Not having an explicit description of the solution, the work packages were arranged into different development phases, in accordance to Agile development guidelines \cite{wysocki_2013}. All phases ended with a feedback loop to assess their completion, helping to determine if the next phase could start or if a new cycle of the current step should be launched to further shape the work packages involved. Following this model aided in managing the complexity and uncertainty of the project, every cycle converging to a complete solution. Five development stages were planned, each starting with a partial perception of it's expected result and based upon certain assumptions about the input received and completion level of the previous cycles, thus establishing the five major milestones of the project. Aiming both to fulfil already existing tasks and to identify new functionalities for the system resulted in the definition and completion of the end system.\\

\begin{figure}[!ht]
\centering
\includegraphics[scale=0.2]{img/phase1.png}
\caption{First phase of the project plan}
\label{fig:phase1}
\end{figure}

The first phase was the most crucial as it's main purpose was to identify and perform the abstraction of all the business entities involved in the system. In addition, the data structures had to be clearly defined in order to start designing a coherent database structure. This was particularly challenging as the elements this system targeted were subjective and based upon customer preferences, so the requirements analysis performed had to be extensive. Further on, the server component had to be designed and implemented as it was responsible for all the generated system's business logic, acting as a middle point between the database and both the iOS and Web clients. The first milestone was considered reached when the server, the database and a rudimentary iOS mobile application were created and the communication between them was functional, these components representing the deliverables of the initial stage.\\

\begin{figure}[!ht]
\centering
\includegraphics[scale=0.2]{img/phase2.png}
\caption{Second phase of the project plan}
\label{fig:phase2}
\end{figure}

The second phase comprised the work packages related to the iOS application template. The launching of this stage implied that the server was active and that the system's functionalities were already implemented. Thus, the iOS client development stage would revolve around presenting the information received from the server and the specific mobile features of the system. However, this was expected to be a time consuming and of a high importance process as this component is the main interaction point with potential customers. In addition, the augmented reality feature increased the level of uncertainty for this cycle. The deliverable of this phase was a fully functional iOS mobile application template, upon the completion of which the second milestone was considered to be reached.\\

The third phase of the project schedule (Figure~\ref{fig:phase3} in the Appendix) plans the work packages responsible for the creation of the Web application and the generation platform. This stage was expected to be less complex than the iOS application development, as a number of features were not included in this client platform, because they had to make use of particular hardware functionalities not available to a browser, such as geometric sensors and video camera usage. However, the main generation system proved to be more complex than expected, requiring an extra cycle for the completion of this phase. The milestone was reached when all of the established features were implemented, the deliverable being a functional client Web interface template and a generation system.\\

The fourth and fifth phases (Figure~\ref{fig:phase4} in the Appendix) consisted of deploying, debugging and testing the overall system, thus being dependent on the deliverables from the previous cycles. Extra time was allocated for each work package involved, as neither of the components were yet extensively tested. Thus, a time margin was granted for fixing any system or logic issue that became visible. Reaching the milestone of the fifth stage implied that the project's solution was identified and created, this being asserted by evaluating the system based upon the success criteria of the Conditions of Satisfaction.

\subsection{System Design}
As an Agile project, the functionalities, features and even requirements may change throughout the development process. In order to increase the efficiency and reliability of the software solution, Model Driven Development has been chosen as the main approach for designing and implementing both the main and generated systems. Through model creation and transformation, the complexity of the project will be reduced. As the initial step towards developing the solution is the abstraction of the components and interactions, this will aid in maintaining the core functionalities throughout the usage of multiple types of programming languages, as well as in the case of changing an already used technology. In addition, following MDD techniques provides clear steps in case of changing or reusing the components involved \cite{lano_2009}. This section aims to present the steps taken for outlining the resulted overall system design.\\

The first step towards identifying and defining the main functionalities and components of the system is to create a Platform Independent Model. The system model regarding the core domain notions and software independent structures helps to convey the high-level functionalities of the system, as well as provide flexibility and reusability across both the iOS and the Web platforms. This has been achieved by outlining the Business Concept Model based upon the business requirements identified in the previous section, in addition to the system requirements resulted from establishing the Use Cases for the two systems described by this project \cite{sastry_2017}. The Unified Model Language was chosen to present the elements of all the design and architecture components of this project.

\subsubsection{Use Cases}

In order to identify the expected system actions and the dynamic behaviour it must have, a number of Use Cases have been drafted and linked in a Use Case Diagram. This lead to a more in depth understanding of what the sequences of actions should be, thus giving insight for outlining the system's event processing order. This step also provided the means to recognise the actors involved in the usage of the solution, being able to tailor the functionalities based on their positive experience. Through this process, an overview of the components' workflows were able to be identified, providing the sequence of steps needed in order to ensure a successful interaction. The most important Use Case scenarios have been described in detail in this section to further establish the system's functionalities and requirements.\\

\begin{figure}[!ht]
\centering
\includegraphics[scale=0.2]{img/Use_Case_diagrams.png}
\caption{Use Case diagrams for the main and generated systems}
\label{fig:use_case_diagrams}
\end{figure}

As seen in Figure~\ref{fig:use_case_diagrams} , the generation system has two main Use Cases for the interaction with the potential clients, which are abstracted into the Client actor. Following the scenarios of the two cases provides the necessary steps for which a solution can be customised and generated successfully, thus comprising the guidelines for using the main program. The user must first pass through the 'Customise retail system' use case, in which all the generated retail logic components and customisation options must be defined. These include the name of the solution, a number of classification parameters such as the targeted type of vendors and offer categorising, as well as the colours of the visual elements. The 'Purchase retail system' case uses the client's preferences as input in order to generate a complete solution and provide the download links for it. This can only be done after the user provides a valid form of payment and the transaction is complete. Thus, this use case includes the first one, forming together the necessary set of steps for the usage of this project's main system.\\

Most of the success criteria and requirements identified in the scoping process concern the generated solution, as it represents the deliverable for the transactions with potential clients and is the main element that provides business value. It's complexity implied a larger number of functionalities, thus leading to multiple use case scenarios for potential customers. The actors identified for the interaction with the system are the customers and the vendors. As there are two different platforms of interaction, the customer actor can be either a web or an iOS application user, both having a large common base of functionalities to use. However, as the mobile application is the main platform, the iOS user has more features at his disposal, such as augmented reality navigation. In addition, taking into account the reliability of the system and maintaining a logical sequence of activities in the user interaction, most use cases depend on the successful completion of the sequences of steps stated in other scenarios.\\

This applies to the 'Authenticate' use case among others. The system verifies the credentials entered by the customer actor and either grants access to the application functionalities or alerts the user that access is denied. However, a successful pass through this scenario is based on the completion of the 'Register' use case beforehand. Thus, only by creating an account will the system be able to identify the actor as a user with the necessary permissions. This is only part of the sequence of steps needed to undergo to use the platforms, as the 'Authenticate' scenario is included in most of the others.\\

Adding credit to an existing account implies that a customer has already authenticated, this use case regarding both type of users. The topping up process is of high importance for the system as it is required for the purchasing of offers, the main revenue source of the vendors and the potential clients. Thus, a scenario has been outlined in order to establish the required steps for customers to successfully credit their account.\\

\noindent 'Add Credit' success scenario:\\
\indent 1. Customer accesses the profile page (having authenticated beforehand)\\
\indent 2. Customer selects to add credit\\
\indent 3. Customer enters the desired amount\\
\indent 4. Customer enters card credentials\\
\indent 5. System authorizes the crediting\\
\indent 6. System alerts customer of the successful tranzaction\\
\indent 7. System credits the customer's account\\
Extensions:\\
\indent 5b. System rejects the transfer\\
\indent\indent 4b.1. Customer may reenter the card credentials or may cancel\\

One of the most important scenarios for the attainment of the project requirements is the successful completion of a purchasing and redeeming cycle. This sequence of actions ends with the vendor actor proceeding with claiming a valid receipt. However, there are number of successive use cases included in this process. After the authentication, the next important step is to undergo the 'Purchase offer' scenario:\\

\noindent 'Purchase Offer' success scenario:\\
\indent 1. Customer authenticates\\
\indent 2. Customer browses the offers and selects a location\\
\indent 3. System provides appointment intervals (service based vendors)
\indent 4. Customer chooses an appointment interval (service based vendors)\\
\indent 5. System authorises the purchase\\
\indent 6. System provides an electronic receipt\\
Extensions:\\
\indent 5b. System rejects the purchase\\
\indent\indent 5b.1. Customer may add credit or may cancel\\

The last step for redeeming a receipt can only be initiated by an iOS application user, as an initial requirement of the system and as the web component is dedicated to desktop users for the initial version. Thus, after a customer purchases an offer, he is expected to redeem it at the selected location in between the established hours (either between the location's hours for the product based solution or in the appointment interval selected for the service based systems). The main actor in redeeming a receipt is the vendor, as by doing it personally is the only way to ensure that each offer is checked out only once.\\

\noindent 'Redeem Receipt' success scenario:\\
\indent 1. Vendor presses the receipt button\\
\indent 2. System asks for confirmation\\
\indent 3. Vendor provides confirmation\\
\indent 4. System verifies the receipt's validity\\
\indent 5. System approves the redeeming of the receipt\\
\indent 6. Vendor provides the service or product implied\\

One of the most interesting features of the iOS application is the augmented reality navigation. The system calculates the distance to the selected location and provides step by step directions using the iOS device's video camera. The only actor that initiates this use case is the iOS application user, as this functionality depends on specific measurements provided by mobile devices. However, this scenario extends the 'GPS navigation' use case, which is available to both types of customers. The scenario is considered to be successful when the actor arrives at the selected destination.\\

\indent 'GPS Navigation' success scenario:\\
\indent 1. Customer authenticates\\
\indent 2. Customer presses the navigation button\\
\indent 3. System presents the options of providing directions\\
\indent 4. Customer selects navigation via maps\\
\indent 5. System presents a map with step by step directions toward the destination\\
\indent 6. Customer follows the directions until the arrival at the end point\\
Extensions:\\
\indent 4a. Customer selects the 'Augmented reality navigation' scenario:\\
\indent\indent 4a.1. System opens the camera with labels for the step by step directions\\
\indent\indent  4a.2. Costomer follows the directions shown on the camera overlay\\
\indent\indent  4a.3. System shows an alert upon the arrival and closes the camera

\subsubsection{Business Type Model}

Identifying the core elements is important as the system will be further shaped based upon them. As a result, a number of steps have been covered in order to ensure that the resulting component design is reliable, first being to gather all the elements involved in the lifecycle of the solution and to outline the relationships and dependencies between them. The representations of the domain elements and the associations between them formed the Business Concept Model, an initial design of the entities used and handled in the business domain that this system tackles (Figure~\ref{fig:business_concept_model} in the Appendix).\\

As the project aims to develop a customisable solution, both the main and the generation systems had to be analysed separately. The abstraction of the main component's elements resulted in a set formed of the potential clients, the main system, the customised solution with different possible types and the orders placed for them. Contrary to the reduced complexity of the generation platform's business domain, the group of elements that comprise the custom system's field of interaction proved to be very extensive, covering elements from the types of vendors and offers to the connections with the customers.\\ 

The next step into refining the business entities was to classify the elements of the Business Concept Model by identifying what components are of core, dependent or the category type. The aim of this task was to distinguish the sections which correspond to primary business information, thus forming the starting point of the component identification process. The method used to differentiate them was analysing which were stand-alone entities and which were coherent only through their relationship with others. The latter could then be split by checking if they provided means of categorising the main elements or just depended on them. The resulted model for the proposed generated system is presented in Figure~\ref{fig:business_type_model}.\\

\begin{figure}[!ht]
\centering
\includegraphics[scale=0.3]{img/Business_Type_Model.png}
\caption{Business Type Model with Business Interfaces}
\label{fig:business_type_model}
\end{figure}

The single core entity of the generation component was found to be the Client. The System Type was easily identified as belonging to the category type, while the Customisable System depended on the Order piece, which in turn depended on the Client. Similarly, the customised template system was comprised of two core elements, the Customer and the Vendor segments, while the others were found to be related to the latter. The Category component provides classification criteria for the Product element, in the same way as Type is a category entity for the Vendor core segment. The rest were identified as dependent types for either the main items or for each other.\\

\subsubsection{Component Identification}
The acquired data obtained through the abstraction of the business elements and the system functionalities identified through formulating the use cases could then be used to model an initial overview of the system's architecture. However, the components that comprise it needed to be defined and the communication interfaces established. In accordance to software design and architecture guidelines, the dependent and category types of the business model belonged to a span of responsibility of the core types. As a result, the interaction points through which these elements could be accessed would be via the core elements, resulting in the identification of these regions as the system's business components and their access points as the business interfaces \cite{hamza_2017}. The resulting business components are the Customer and the VendorManagement elements with the ICustomerManagement and IVendorManagement interfaces as can be seen in Figure~\ref{fig:business_type_model}. The operations present for the business interfaces are the descriptions of the interaction between the business and system components.\\

\begin{figure}[!ht]
\centering
\includegraphics[scale=0.3]{img/System_Interfaces.png}
\caption{System Interfaces}
\label{fig:system_interfaces}
\end{figure}

Following the same set of design rules, the system interaction with the business elements would be achieved through interfaces resulted from the system's behaviour in the use cases, with the limit of one such interface per every main use case. In consequence, the system would form a single component with multiple interaction points. The identified system interfaces can be seen in Figure~\ref{fig:system_interfaces}. Analysing the use case of the generating component lead to the decision that its only interface would be the IGenerate communication point which provided the means of customising a solution and deploying it. Seven different interfaces were thus identified for the retail system, the first of which being the IAuthenticate terminal in charge of checking credentials and creating new accounts operations. IEditProfile would be responsible for presenting and managing user profile details, IAddCredit would provide the crediting authorisation and updating and INavigate would present the directions based on different settings, as well as handle the augmented reality navigation. The IPurchase and IRedeem interfaces would be responsible for the managing and redeeming of offers and the IRateLocation with the feedback operations.\\
\begin{figure}[!ht]
\centering
\includegraphics[scale=0.3]{img/Initial_Architecture}
\caption{System Interfaces}
\label{fig:initial_architecture}
\end{figure}

Having identified and designed both the system and business components, their connection formed a rudimentary architecture of the overall system. By separating the generating and the customisable solutions, the component diagram in Figure provides an initial point from which further analysing and designing the components and communication of both systems would lead to a final coherent system architecture.

\subsection{System Architecture}

The initial architectural design identified in the previous section provides the necessary data to analyse and decide upon an overall structure. The best choices for a system with a server component and multiple client platforms are the client-server and the N-tiered architectures, both of which provide and define the means of interaction between the two main structures of the system, no matter their composition level. The reason for which they are the best fit is that both the generating and the customisable retail systems require communication functionalities from presentation elements such as web and iOS applications to the system logic elements which reside on remote servers. This interaction is attained by requesting services and data from the server component, which in return provides the responses, the reverse not being permitted. In addition, these types of architectures target systems with more than one client platforms and only one centralised logic system that manipulates the information and manages the business data, as well as performs more computing intense processes.\\

The decision that needed to be made at the time was whether to use the client-server or the N-tiered architecture for each of the systems. The difference between the two types is that the latter has the components separated in more than two layers, whereas the other has only two main tiers. Each two consecutive layers of the N-tiered structure have a client-server design, thus allowing the elements from the higher-level tiers to request information and services from the next lowest. With regard to the generating and customisable platforms, the choice was either a client-server architecture or a 3-tiered one in which the data storage component would be migrated to a physically separate server. However, as the time and resources for developing the solution were limited, the decision was made to use the first structure, allowing the possibility of further developing the systems in future releases.\\